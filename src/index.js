// Generated by LiveScript 1.5.0
/**
 * @package Detox utils
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  var string2array, array2string;
  if (typeof Buffer !== 'undefined') {
    /**
     * @param {string} string
     *
     * @return {!Uint8Array}
     */
    string2array = function(string){
      return Buffer.from(string);
    };
    /**
     * @param {!Uint8Array} array
     *
     * @return {string}
     */
    array2string = function(array){
      return Buffer.from(array).toString();
    };
  } else {
    (function(encoder, decoder){
      /**
       * @param {string} string
       *
       * @return {!Uint8Array}
       */
      string2array = function(string){
        return encoder.encode(string);
      };
      /**
       * @param {!Uint8Array} array
       *
       * @return {string}
       */
      array2string = function(array){
        return decoder.decode(array);
      };
    }.call(this, new TextEncoder(), new TextDecoder()));
  }
  /**
   * @param {!Uint8Array} array
   *
   * @return {string}
   */
  function array2hex(array){
    var string, i$, len$, byte;
    string = '';
    for (i$ = 0, len$ = array.length; i$ < len$; ++i$) {
      byte = array[i$];
      string += byte.toString(16).padStart(2, '0');
    }
    return string;
  }
  /**
   * @param {string} string
   *
   * @return {!Uint8Array}
   */
  function hex2array(string){
    var array, i$, to$, i;
    array = new Uint8Array(string.length / 2);
    for (i$ = 0, to$ = array.length; i$ < to$; ++i$) {
      i = i$;
      array[i] = parseInt(string.substring(i * 2, i * 2 + 2), 16);
    }
    return array;
  }
  /**
   * @param {!Uint8Array}	array1
   * @param {!Uint8Array}	array2
   *
   * @return {boolean}
   */
  function are_arrays_equal(array1, array2){
    var i$, len$, key, item;
    if (array1 === array2) {
      return true;
    }
    if (array1.length !== array2.length) {
      return false;
    }
    for (i$ = 0, len$ = array1.length; i$ < len$; ++i$) {
      key = i$;
      item = array1[i$];
      if (item !== array2[key]) {
        return false;
      }
    }
    return true;
  }
  /**
   * @param {!Array<!Uint8Array>} arrays
   *
   * @return {!Uint8Array}
   */
  function concat_arrays(arrays){
    var total_length, current_offset, result, i$, len$, array;
    total_length = arrays.reduce(function(accumulator, array){
      return accumulator + array.length;
    }, 0);
    current_offset = 0;
    result = new Uint8Array(total_length);
    for (i$ = 0, len$ = arrays.length; i$ < len$; ++i$) {
      array = arrays[i$];
      result.set(array, current_offset);
      current_offset += array.length;
    }
    return result;
  }
  /**
   * Changed order of arguments and delay in seconds for convenience
   */
  function timeoutSet(delay, func){
    return setTimeout(func, delay * 1000);
  }
  /**
   * Changed order of arguments and delay in seconds for convenience
   */
  function intervalSet(delay, func){
    return setInterval(func, delay * 1000);
  }
  function error_handler(error){
    if (error instanceof Error) {
      return console.error(error);
    }
  }
  function Wrapper(detoxBaseX, arrayMapSet, randomBytesNumbers){
    var random_bytes, random_int, random, base58;
    random_bytes = randomBytesNumbers['random_bytes'];
    random_int = randomBytesNumbers['random_int'];
    random = randomBytesNumbers['random'];
    /**
     * Generates exponentially distributed numbers that can be used for intervals between arrivals in Poisson process
     *
     * @param {number} mean
     *
     * @return {number}
     */
    function sample(mean){
      return -Math.log(random()) * mean;
    }
    /**
     * @template T
     *
     * @param {!Array<T>} array Returned item will be removed from this array
     *
     * @return {T}
     */
    function pull_random_item_from_array(array){
      var length, index;
      length = array.length;
      if (length === 1) {
        return array.pop();
      } else {
        index = random_int(0, length - 1);
        return array.splice(index, 1)[0];
      }
    }
    base58 = detoxBaseX('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
    return {
      'random_bytes': random_bytes,
      'random_int': random_int,
      'sample': sample,
      'pull_random_item_from_array': pull_random_item_from_array,
      'array2hex': array2hex,
      'hex2array': hex2array,
      'string2array': string2array,
      'array2string': array2string,
      'are_arrays_equal': are_arrays_equal,
      'concat_arrays': concat_arrays,
      'timeoutSet': timeoutSet,
      'intervalSet': intervalSet,
      'error_handler': error_handler,
      'ArrayMap': arrayMapSet['ArrayMap'],
      'ArraySet': arrayMapSet['ArraySet'],
      'base58_encode': base58['encode'],
      'base58_decode': base58['decode']
    };
  }
  if (typeof define === 'function' && define['amd']) {
    define(['@detox/base-x', 'array-map-set', 'random-bytes-numbers'], Wrapper);
  } else if (typeof exports === 'object') {
    module.exports = Wrapper(require('@detox/base-x'), require('array-map-set'), require('random-bytes-numbers'));
  } else {
    this['detox_utils'] = Wrapper(this['base_x'], this['array_map_set'], this['random_bytes_numbers']);
  }
}).call(this);
